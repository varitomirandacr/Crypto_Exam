
## Linear Feedback Shift Registers (LFSR)
A standard way of producing a binary stream of data is to use a feedback shift register. These are small circuits containing a number of memory cells, each of which holds one bit of information. The set of such cells forms a register. In each cycle a certain predefined set of cells are â€œtappedâ€ and their value is passed through a function, called the feedback function.

- Each state is obtained from previous state, via matrix multiplication
- Outputting bits produces a vector product (s = 0,1,0,1,0,1,0,1)
- The register is the combination of tapped bits, length = $L$
- The output sequence is then defined to be s0,s1,s2,...,sLâˆ’1,sL,sL+1,... where for $j â‰¥ L$ we have:
$$ s_{j} = c_{1} Â·s_{jâˆ’1} \oplus c_{2} Â·s_{jâˆ’2} \oplus Â·Â·Â· \oplus c_{L} Â·s_{jâˆ’L} $$

<br/>
<hr/>

## Connection Polynomial
The connection polynomial and the matrix are related via
$$ ğ¶(ğ‘‹)=1+ğ‘_{1} â‹…ğ‘‹+ğ‘_{2} â‹…ğ‘‹^{2} + . . . + ğ‘_{ğ¿} â‹…ğ‘‹^{ğ¿} $$
$$ C(X) = det(X \cdot M âˆ’ I_{L}) $$
$$ \in ğ”½_{2}[ğ‘‹] $$
$$ reverse \ = \ G(X) = X^{L} Â· C(1/X)$$

```
-> | $S_{2}$ | $S_{1}$ | $S_{0}$ $ --->
|       |                   |
|______ âŠ• __________________|
```
Connection Polynomial = $X^{2} + 1$

A connection polynomial $ğ¶(ğ‘‹)$ is primitive if
- it is irreducible, and
- a root $\theta$ generates the multiplicative group of the field $ğ”½_{2ğ‘›}$

A connection polynomial $ğ¶(ğ‘‹)$ is primitive if 
- $ğ”½_{2}[ğ‘‹]/(ğ¶(ğ‘‹)) = ğ”½_{2}(\theta) = ğ”½_{2ğ‘›}, and$
- $ğ”½_{2ğ‘›}^{*} =âŸ¨\thetaâŸ©$

<br/>
<hr/>

## Linear Complexity
An important measure of the cryptographic quality of a sequence.
We define the linear complexity of $s$ as $L(s)$ where:
- $L(s) = 0$ if s is the zero sequence
- $L(s) = âˆ$ if no LFSR generates s
- $L(s)$ is the length of the shortest LFSR to generate s, otherwise.

Properties:
- For all $n \geq 1$ we have $0 \leq L(s^{n}) \leq n$
- If $s$ is periodic with period $N$ then $L(s) \leq N$
- $L(s\oplus t) \leq L(s)+L(t)$

<br/>
<hr/>

## Combining LFSRs
To obtain greater security a common practice is to use a number, say n, of LFSRs, each producing a different output sequence $x_{1}^{(i)}, . . . , x_{n}^{(i)}$. The key is then the initial state of all of the LFSRs

$$ f(x1,x2,x3,x4,x5) = 1\oplus x2 \oplus x3 \oplus (x4 Â·x5)\oplus (x1 Â·x2 Â·x3 Â·x5) $$

Amazing fact is that the linear complexity of the keystream generated by $f(x_{1},...,x_{n})$ is equal to $f(L_{1},...,L_{n})$

**Theorem (Linear Complexity of Combined LFSRs)**
Let $ğ‘“(ğ‘¥_{1}, ... , ğ‘¥_{ğ‘›})$ be a non-linear function and 
- $ğ‘›$ LFSRs generated by a primitive connection polynomial 
- each $ğ¿_{ğ‘–} > 2 (1 \leq ğ‘– \leq ğ‘›)$
- each $ğ¿_{ğ‘–} \neq ğ¿_{ğ‘—} (ğ‘– \neq ğ‘—)$
then, $ğ¿(ğ‘“)=ğ‘“(ğ¿_{1},...,ğ¿{ğ‘›})$ with $\oplus $ andâ‹…in $ğ”½_{2}$ replaced by+ andâ‹…in $Z$

<br/>
<hr/>

## Recovering the State
Shift register recursion:
$$ \sum_{i=1}^{L} c_{i} \cdot s_{j-i} = s_{j}, j \geq L$$
where $c_{0} = 1$
$$ \sum_{i=0}^{L} c_{i} \cdot s_{j-i} = 0, j \geq L$$

Given $2ğ¿$ outputs (i.e., $ğ‘ ^{2ğ¿}$), we can recover $ğ‘_{1}, ... , ğ‘_{ğ¿}$ by solving: Matrix multiplications of C's by Matrix of states

<br/>
<hr/>

## RC4 Stream Cipher: No LFSRs
Ronâ€™s Cipher after Ron Rivest of MIT

- RC4 not previous version neither related to RC5 and RC6
- very fast stream cipher
- easy to remember since it is surprisingly simple
- widely deployed in browsers to secure traffic to websites using the TLS protocol

Issues:
- Not really random
- In particular, each output byte has a particular bias
- RC4 should no longer be used

How it works:
- RC4 we take an array S, indexed from 0 to 255, consisting of the integers 0, . . . , 255
- The output of the RC4 algorithm is a keystream of bytes K which is exclusive-orâ€™ed with the plaintext byte by byte
- i = 0 and j = 0, then repeat steps
$$
iâ†(i+1) mod256 \\
jâ†(j+Si) mod256 \\ 
swap(Si,Sj) \\ 
tâ†(Si+Sj) mod256 \\
K â† St.
$$

if the attacker knows K and i, he can deduce the value of St, but this does not allow him to deduce anything about the internal state of the table

## Trivium Stream Cipher: No LFSRs
## Non-linear Function
## Geffe Generator
## Filter Generator
## Alternating-Step Generator
## Shrinking Generator
## A5/1 Generator
## Feistel Cipher
## Data Encryption Standard (DES)

